Interesting links:
http://www.marekknows.com/index.php
http://nccastaff.bournemouth.ac.uk/jmacey/RobTheBloke/www/opengl_programming.html
http://www.robots.ox.ac.uk/~gsibley/GLConsole/
http://www.ee.oulu.fi/~kapu/cg_course/bigfiles/3_projct_4.pdf   #see this for glFrustrum and glOrtho math details

Resources:
SOIL image library (or devil library for really advanced stuff, but SOIL is great)
ftgl for font rendering
glfw for window management
assimp for model loading


----------------------------------------------------------------------------------------------------------
Processes:
Establish viewport with glViewport(). For example glViewport(0, 0, 400, 600);
Then do whatever.

The whatever can be: 
A) Establish 3D projection with:
// Normally the call to glFrustrum is replaced with gluPerspective() like:
// gluPerspective( 67.0f, width / (double) height, 1.0f, 100.0f);      // this 100% work.
// If you don't like glu library, then gluPerspective is open source, so just copy its body :)
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
glFrustum(0, 2, -1, 0.5, 1, 10);    // these are more or less sensible values. Note: (near != 0)

glMatrixMode(GL_MODELVIEW);
glLoadIdentity();


B) Establish 2D projection with this (but remember to also glDisable() the 3D features that are useless in 2D):
// if you want this projection only temporarily just push a matrix 
// and pop it after all your 2D rendering is done:
// glPushMatrix();
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
glOrtho(0, width, 0, height, -1.0, 1.0);

glMatrixMode(GL_MODELVIEW);
glLoadIdentity();

..... // draw 2D stuff
// glPopMatrix();


C) Give various settings:
// will normalise all the given normals vectors. This is important for lighting. This is expensive,
// use it to check if your model has weird shading because of non unit normals.
glEnable(GL_NORMALISE);

glClearColor(1.0f, 0.95f, 0.7f, 1.0f);             // Nice yellow color
glClearColor(0.5f, 0.78f, 1.0f, 1.0f);      // Nice blue color, note: last parameter is a 1.0. I dunno why.

// now when you do glColor__() the material will be affected. Otherwise you would have to do glMaterial___()
glEnable(GL_COLOR_MATERIAL);    

// for textures
glEnable(GL_TEXtURE_2D);

Common for 3D:
    glEnable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
Common for 2D:
    Disable the thing for 3D above except for GL_LIGHTING.



--------------------------------------------------------------------------------------------------------
Tips and Pitfalls:
0) By default OpenGL camera is facing down the negative z axis. Positive Y is up and positive X is leftwards.

1) When you draw a polygon (or a quad or a triangle) the order in which you supply the vertices is important.
Do you give them in clockwise or anti-clockwise order? This effect the direction of the polygon, if opengl 
decides that it is facing away from you, it will NOT be drawn. To control this see documentation to 
glFrontFace() and options GL_CW and GL_CCW. If you do glDisable(GL_CULL_FACE) then all polygons will be drawn, 
no matter their face direction (great for debugging).

2) For 2D mode you can control where your (0,0) origin is. If you want bottom left corner (the default) use 
`glOrtho(0, win_width, 0, win_height, -1, 1);` If you want the origin in top left corner like SDL (and pygame) do
then simply use `glOrtho(0, win_width, win_height, 0, -1, 1);` Likewise you can screw up your origin any way
you like. The _near_ and _far_  (last 2 arguments) to glOrtho define clipping planes. Plane 1 is at distance 1
forward from your screen. Plane 2 is at distance 1 backwards from your screen. Everything that you draw between
these planes will be visible (so if you glTranslate(0.0, 0.0, 0.9); all is ok, but glTranslate(0.0, 0.0, 1.1);
then you shape will be invisible). If you use glVertex2i (as you should instead of glVertex2f) the shapes 
will be drawn at 0 distance, as 0 is between -1 and 1, hence the shapes will be visible. 

3) When you are in 2D mode after glOrtho(), it is MUCH more logical to use glVertex2i (NOT glVertex2f). Because
this value is in pixels (its NOT in just 'opengl units'). So it will be clamped anyway! So use integers, its
better practice and you can avoid many wierd bugs.

4) Always remember the first thing to do is check glGetError() and interpret it!

5) OpenGL multiplies all positions and rotations through each matrix; so when for instance you draw 
a polygon (glBegin(GL_FACE), some points, glEnd()), it translates the polygon to "world space" by 
multiplying each point with the with the MODELVIEW, and then translates it from 3D to 2D by multiplying 
it with the PROJECT matrix, and that gives it the 2D points on screen, along with the depth (from the 
screen 'camera'), which it uses to draw pixels.

6) You might need to place this line before binding the texture. This functions performs some environment
tweaks. (Need more research. But it allows you to have non-darkened textures without light setup!).
glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

7) This lines are necessry, they tell openGL how to work with the texture:
    // Tell OpenGL how to scale images (scale up and scale down) 
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

    // Tell OpenGL how to wrap images (if texture coord is out of bounds)
    // (should you snap it to end? should you do nothing? should you extrapolate color values?)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

8) Rendering texture on rectangle:
//--------------------------------------------------------------------------------------------------
void draw_texture(int x, int y, int width, int height, GLuint texture_id)
{
    //Draw clockwise
    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);      // reset color to white
    glBindTexture(GL_TEXTURE_2D, texture_id);

    glBegin(GL_QUADS);
    glTexCoord2i(1,1); glVertex2i(x+width, y+height);       // right, top
    glTexCoord2i(1,0); glVertex2i(x+width, y);              // right, bottom
    glTexCoord2i(0,0); glVertex2i(x, y);                    // left, bottom
    glTexCoord2i(0,1); glVertex2i(x, y+height);             // left, top
    glEnd();
}



------------------------------------------------------------------------------------------------------------
DEFINITIONS and COMMENTS:
Viewport:
glViewport() specifies that the objects should be drawn to which part of the window. So if you want to draw 
to the whole window you must use the following function:
glViewport( 0,0, gl_window_width, gl_window_height);
If you want to draw to the lower left part of your GL window, then you can use the following function:
glViewport( 0, 0, gl_window_width / 2, gl_window_height / 2 );
and if you want to draw to the lower right part of your GL window, then you can use the following function:
glViewport( gl_window_width / 2, 0, gl_window_width / 2, gl_window_height / 2 );
for example, when you use the above code to draw to the lower part of your OpenGL window, the OpenGL assumes 
that it's a window with width and heights of (width / 2, height /2 ) and its origin is at width / 2 and 0 
relative to to the origin of the actual window which is (0,0). So you get smaller objects when you use smaller 
viewports.( softwares such as 3DSMax and Maya use four independent viewports to draw the objects ).







