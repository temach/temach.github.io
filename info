run arg1 arg2 arg3            will give arg1 arg2 and arg3 to your program as inputs

print varname                 print value of variable
print (char) mydouble         typecast the variable before you print it
print $52                     $34 refers to the result number 34, and plain $ refers to last result
p &mychar                     print variable address
print *(&mychar)              dereference works as well
print myIntArray[3]           print the value of array element
print myIntArray[3]@5         Print 5 elements of my array starting from the 3rd element.

printf "X = %d, Y = %d\n",X,Y             Does exactly what you think. Actually you can also `call printf(..)`

display varname               Print value of varname _everytime_ the program flow stops (on every break)!!

ptype varname                 print type of variable, function, struct, array, union. Includes field names!!!
ptype myIntArray[3]           print the __type__ of array element

where                               tells you where you are, what frame and other stuff
backtrace                           shows the stack (bt = backtrace)
frame 3                             to select which frame you want now 
continue 50                         will execute continue 50 times
finish                        continues until the function returns. Shows the return value.

set myvariable = 10.0               sets value of variable in your code
p myvariable = 10.0                 does the same thing as set but is shorter. Better use this instead of set.

ignore, enable, disable, clear, delete          for breakpoints
delete                        with no args kills _all_ breakpoints
clear funcname                remove all bp from inside function called funcname
info breakpoints              see all breakpoints

break +3                      set break point 3 lines above currnt line
break filename:linenumber     set break point in some file at some line. Note the : as delimeter.
break                         with no arg set bp on current line
break .... if i==2            conditional bp, the ... is bp location and i==2 is the condition
b 3 Z > 92                    tell gdb to stop at bp number 3 when Z is > 92. Note: the `if` can be omitted

tbreak                        sets a temporaty breakpoint (it is removed after first stop)
ignore 2 5                    ignore bp number 2 for 5 crossings.
watch varname                 set watchpoint on variable
rwatch varname                set a __read__ watchpoint, fires on read of variable.
awatch varname                set all watchpoint (for both read and write)

call myfuncname()             call my function, you format the function call according to language syntax.

info frame                    frame information
info locals                   values of all variables local to the function
info args                     values of args passed to the function

x                             examine memory (see `help x`)
x /4c myvar                   examine myvar as 4 characters 
x /3x myvar                   examine first 3*8 = 24 bytes as hex
x /t myvar                    examine first 4 bytes = 32 bits as binary


core filename                 read core dump file and start gdb from there
info registers                show values in the registers
nexti, stepi                  like next and step but at instuction level (assembley)
disassemble funcname          see disassembled asm code for function

define  macroname             create a macro for quick access




Don't quit debugging session! Execute `kill`, then `run` from the debugger. It will load the changed binary.



Example making a macro of earlier printf command:
(gdb) define pxy
Type commands for definition of "pxy".
End with a line saying just "end".
>printf "%X = %d, Y = %d\n",X,Y
>end


Break points:
1. A breakpoint stops your program whenever a particular point in the program is reached.
2. A watchpoint stops your program whenever the value of a variable or expression changes.
3. A catchpoint stops your program whenever a particular event occurs.

ignore on breakpoint is similar to setting a conditional breakpoint

In gdb this two lines are equal even if mystruct is not a pointer:
print myStruct.name
print myStruct->name

Print using a format specifier, FMT tell gdb how it should interpret the data found at variable's location:
print /FMT variable

where FMT is one of:
o (octal),   x (hex),     d (decimal),    u (unsigned decimal),
t (binary),  f (float),   a (address),    i (instruction), 
c (char),    s (string),  z (hex, zero padded on the left).
  
z FMT is better than x FMT, because z will show all the zeroes!

Breakpoint info looks like:
Breakpoint 1 at 0x8048540: file program3.c, line 55.
To list code around this breakpoint (bp with address 0x8048540) use:
list *0x8048540

So you are debugging a program and you are seeing lots of program output intermixed with debugger output.
What to do? You need to separate the I/O of the debugger and the I/O of the program!
How to do it: http://www.dirac.org/linux/gdb/07-Debugging_Ncurses_Programs.php
Summary:
  get two terminals
  get their device files with `tty` or `whoami`
  use gdb tty command to redirect the output of the debugged program to second terminal: tty /dev/pts/4
  now in first terminal is just gdb output and in second terminal is program output



Abbreviations
bp = breakpoint

br = break cmd
pt = ptype cmd



Good links:
http://www.unknownroad.com/rtfm/gdbtut/gdbwatch.html

http://www.dirac.org/linux/gdb/07-Debugging_Ncurses_Programs.php

http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Debug.html    (apparently very good)
http://heather.cs.ucdavis.edu/~matloff/debug.html
