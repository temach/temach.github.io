First thing to do is `man git`

Most useful:
git log --graph --decorate --all    # to view commit history and branches
git log --follow somefile.txt       # to view previous commits on somefile.txt, even if RENAMED. (git tracks content!) 
git check-ignore -v foo/bar.txt     # to test your gitignore file
git reflog <branchname>             # what git operations you have done. Very useful! (branch is optional)
git grep                            # to search for string in files/commit messages
git fetch and git merge instead of git pull
git reset                           # moving pointers around.
git reset --hard <targetcommit>       # will change to commit and clean uncommited/new files. Run `git status` to check! 
git show                      # this can take a commit id or a tree like object.
git fsck                      # inspect and verify git objects
git branch -avv               # all branches and very verbose. Includes remotes.
git help config               # see possible config options, the corresponding file is .git/config
git commit --amend            # change the last commit. Correct the message/edit the files.
git ls-files                  # what files you have in current state (at this commit/branch). give "-r" for more info
git diff <branchA>:<fileA> <branchB>:<fileB>          # diff between files, what to do to get from state A to B
git branch --edit-description       # description for a branch, but stored only locally in .git/config (can not share)
git commit --no-ff                  # use this over plain git commit, it preserves history in nicer format

Also useful:
git mergetool                 # typically run after a merge with conflicts to do interactive conflict resolution
git clean     # removes untracked files (what about .gitignore'd files?)    
git gc        # garbage collection, removes dangling commits
git gui OR gitk OR git instaweb       # nicely manage your git (no command line)
git stash
git tag
git daemon                     # simple server for git repositories. Can probably be run at home.
git help gitignore            # this is quite useful!
git config color.ui true      # set git to use color when possible by default


Options:
\li almost all commands take `--dry-run` and `--interactive`. With interactive you can git commit in 
      multiple stages a couple of files at a time. This can make commits more logical, and easier to revert.



Behaivour notes:

\li Check you push strategy. (`simple` is the new default. Do `git help config | less` and grep for "simple"). 
    This affects your interaction with the remote. (And why people sometimes mistakenly use `git push --force`)

\li "git tag 1.0" will only create a "lightweight tag", just a pointer. On the other hand "git tag -a 1.0" or 
    "git -s tag 1.0" will create an actual Tag Object (with date/time stamp, author info and so on)

\li By default, git-push pushes all branches, and `git-pull` only pulls the master. 
    (But somehow creates the remote branches like origin/foo and origin/bar ?)

\li When you merge you say `git merge <takebranch> <intobranch>`  if the <intobranch> is none 
    git assumes the current branch. So you merge __into__ the current branch.
    
\li HEAD points at current state. ORIG_HEAD points at previous state.
    HEAD~3 == HEAD~~~ and HEAD^2 == HEAD^^ and weird stuff like HEAD~~^2~ also has meaning.
    The tilde "~" is to go backwards. The caret "^" is to go across parents. 
    So ~ goes primarily left/right and ^ goes primarily up/down.
    
\li a --bare repository is one with only read access. So to do any work you must clone it.


Some extra resources:
http://www.ndpsoftware.com/git-cheatsheet.html
Youtube: Git for ages 4 and up. Really good explanation.
Progit book by Scott Chacon is the deepest on git.
http://gitolite.com/gcs.html    (great "git rebase" and "git cherry-pick" explanation and nice graphs)
